#!/usr/bin/perl
use warnings;
use strict;
use feature ':5.10';

# simple script to get a mailto: for all the active users in GitHub.
# note that the report is cached, so it's not 100% reliable.  you might miss
# a new user, or a newly suspended user, etc.

# only usable by a GitHub admin.  uses $GITHUB_TOKEN environment
# variable, $USER, and curl.

# use -O to try to pass the mailto: to open_url

our $O;

die '$GITHUB_TOKEN is not set in your environment' unless $ENV{GITHUB_TOKEN};
die '$GITHUB_HOST is not set in your environment' unless $ENV{GITHUB_HOST};

my $curl = qq{curl -s -L -u $ENV{USER}:$ENV{GITHUB_TOKEN}};
my $url  = q{https://$GITHUB_HOST/stafftools/reports};

# email is header row, chef-delivery is an app user
my $skip = q{egrep -v ',email,|chef-delivery'};
my $sort = q{sort -t, -k3};

my $users = fetch("$url/all_users.csv", [$skip, $sort]);

my $mailto = '';
for my $user (@$users) {
    my @user = split /,/, $user;
    next if $user[5] eq 'true';
    $mailto .= "$user[3],";
}

if ($mailto) {
    $mailto =~ s/,$//;
    $mailto = 'mailto:' . $mailto;
    if ($O) {
        system('open_url', $mailto);
    }
    else {
        print $mailto, "\n";
    }
}

sub fetch {
    my($full_url, $filters) = @_;
    my $filters_str = $filters ? ' | ' . join(' | ', @$filters) : '';
    my $cmd = qq{$curl $full_url$filters_str};

    my @result = `$cmd`;
    # it could be uncached, so wait and try again
    unless (grep { /\S/ } @result) {
        sleep 10;
        @result = `$cmd`;
    }
    if ((!grep { /\S/ } @result) || $result[0] =~ /Not Found/) {
        die "could not fetch $url, no valid response";
    }

    return \@result;
}
